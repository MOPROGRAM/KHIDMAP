
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Users can read any profile, but only write to their own.
    match /users/{userId} {
      allow read;
      allow write: if request.auth.uid == userId;
    }

    // Usernames must be unique and can only be created/deleted by their owner.
    match /usernames/{username} {
        allow read;
        allow create: if request.auth.uid != null && request.resource.data.uid == request.auth.uid;
        allow delete: if request.auth.uid == get(/databases/$(database)/documents/usernames/$(username)).data.uid;
    }

    // Ratings can be read by anyone, but only created by the rater, who cannot be the rated user.
    match /ratings/{ratingId} {
      allow read;
      allow create: if request.auth.uid != null 
                    && request.resource.data.raterUserId == request.auth.uid
                    && request.resource.data.ratedUserId != request.auth.uid;
    }
    
    // ---- MESSAGING ----
    match /messages/{chatId} {
      // Allow GETting a chat document only if the user is a participant.
      allow get: if request.auth.uid in resource.data.participantIds;

      // Allow LISTing chats for any authenticated user. The client-side query MUST filter for the user's own chats.
      // This is a common pattern for "inbox" style collections.
      allow list: if request.auth.uid != null;
      
      // Allow CREATEing a chat only if the creator is one of the participants.
      allow create: if request.auth.uid != null && request.auth.uid in request.resource.data.participantIds;
      
      // Allow UPDATE on a chat document (e.g., to update last message, unread count) only if the user is a participant.
      allow update: if request.auth.uid in resource.data.participantIds;

      // ---- Messages Subcollection ----
      match /messages/{messageId} {
        // Participants of the parent chat can read and create messages.
        allow read, create: if request.auth.uid in get(/databases/$(database)/documents/messages/$(chatId)).data.participantIds;
        
        // Participants can only update a message to mark it as read by them. They cannot change content.
        allow update: if (request.auth.uid in get(/databases/$(database)/documents/messages/$(chatId)).data.participantIds)
                      && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['readBy']);
      }
    }

    // ---- CALLING ----
    match /calls/{callId} {
      // Allow GETting a call document only if the user is a participant.
      allow get: if request.auth.uid in resource.data.participantIds;

      // Allow LISTing calls for any authenticated user. The client MUST filter these securely.
      // This is necessary for the incoming call listener to work.
      allow list: if request.auth.uid != null;

      // Allow CREATEing a call only if the creator is the caller.
      allow create: if request.auth.uid != null && request.resource.data.callerId == request.auth.uid;

      // Allow UPDATEing a call (e.g., status, offer, answer) only if the user is a participant.
      allow update: if request.auth.uid in resource.data.participantIds;

      // ---- Candidates Subcollections ----
      match /callerCandidates/{candidateId} {
        allow read, create: if request.auth.uid in get(/databases/$(database)/documents/calls/$(callId)).data.participantIds;
      }
      match /calleeCandidates/{candidateId} {
        allow read, create: if request.auth.uid in get(/databases/$(database)/documents/calls/$(callId)).data.participantIds;
      }
    }
  }
}
