rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function to check if a user is authenticated
    function isUserAuthenticated() {
      return request.auth != null;
    }

    // Helper function to check if the requesting user is a participant in a document
    function isParticipant(docId, collectionName) {
      return request.auth.uid in get(/databases/$(database)/documents/$(collectionName)/$(docId)).data.participantIds;
    }

    // USERS collection: Public profiles for providers, private for others.
    match /users/{userId} {
      // Anyone can read a provider's profile. Seekers/Admins can read their own.
      allow get: if get(/databases/$(database)/documents/users/$(userId)).data.role == 'provider'
                  || (isUserAuthenticated() && request.auth.uid == userId);
      
      // All authenticated users can list providers for the search page.
      allow list: if isUserAuthenticated();

      // Users can only create and update their own profile.
      allow create, update: if isUserAuthenticated() && request.auth.uid == userId;

      // Users can only delete their own profile.
      allow delete: if isUserAuthenticated() && request.auth.uid == userId;
    }

    // USERNAMES collection: Ensures username uniqueness.
    match /usernames/{username} {
      // Anyone can check if a username exists.
      allow get;
      // Only the user themselves can claim a username.
      allow create: if isUserAuthenticated() && request.resource.data.uid == request.auth.uid;
      // Only the user themselves can delete their username document.
      allow delete: if isUserAuthenticated() && resource.data.uid == request.auth.uid;
    }

    // RATINGS collection: For user reviews.
    match /ratings/{ratingId} {
      // Anyone can read/list ratings.
      allow get, list;
      // Only authenticated users can create ratings for others.
      allow create: if isUserAuthenticated() && request.resource.data.raterUserId == request.auth.uid;
    }

    // MESSAGES collection: Represents a chat conversation.
    match /messages/{chatId} {
      // Allow GET, UPDATE, DELETE only for participants of the chat.
      allow get, update, delete: if isUserAuthenticated() && isParticipant(chatId, 'messages');
      
      // Allow LIST for authenticated users (client-side query must enforce filtering).
      allow list: if isUserAuthenticated();

      // Allow CREATE if the creator is a participant.
      allow create: if isUserAuthenticated() && request.resource.data.participantIds[request.auth.uid] == true;

      // MESSAGES subcollection: The actual messages within a chat.
      match /messages/{messageId} {
        // Allow participants to list and get messages.
        allow get, list: if isUserAuthenticated() && isParticipant(chatId, 'messages');
        // Allow participants to create messages. Sender must be the authenticated user.
        allow create: if isUserAuthenticated() && isParticipant(chatId, 'messages') && request.resource.data.senderId == request.auth.uid;
      }
    }

    // CALLS collection: For WebRTC signaling.
    match /calls/{callId} {
      // Allow CREATE if the caller is the authenticated user.
      allow create: if isUserAuthenticated() && request.resource.data.callerId == request.auth.uid;

      // Allow participants to read or update the call document (e.g., status, answer).
      allow get, update: if isUserAuthenticated() && isParticipant(callId, 'calls');
      
      // Allow list for participants (e.g., to find ringing calls).
      allow list: if isUserAuthenticated();

      // ICE CANDIDATES subcollections.
      match /{candidatesCollection}/{candidateId} {
        // Allow participants of the parent call to read and create ICE candidates.
        allow get, list, create: if isUserAuthenticated() && isParticipant(callId, 'calls');
      }
    }
  }
}